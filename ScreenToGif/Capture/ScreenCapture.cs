using ScreenToGif.Domain.Enums;
using ScreenToGif.Domain.Models.Recording.Events;
using ScreenToGif.Model;
using ScreenToGif.Util;
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace ScreenToGif.Capture;

internal class ScreenCapture : BaseCapture, IScreenCapture
{
    private FileStream _eventsFileStream;
    private BufferedStream _eventsBufferedStream;
    private Task _eventConsumerTask;
    private BlockingCollection<RecordingEvent> _eventConsumer;

    #region Properties

    public int Left { get; set; }

    public int Top { get; set; }

    /// <summary>
    /// The image in pixels of the cursor.
    /// </summary>
    public byte[] Cursor { get; set; }

    public int CursorWidth { get; set; }

    public int CursorHeight { get; set; }

    /// <summary>
    /// The name of the monitor device where the recording is supposed to happen.
    /// </summary>
    public string DeviceName { get; set; }

    public bool WasEventCaptureStarted { get; set; }

    public bool IsAcceptingEvents { get; set; }

    #endregion

    public virtual void Start(int delay, int left, int top, int width, int height, double scale, ProjectInfo project)
    {
        base.Start(delay, width, height, scale, project);

        Left = left;
        Top = top;

        _eventsFileStream = new FileStream(project.EventsPath, FileMode.Create, FileAccess.Write, FileShare.None);
        _eventsBufferedStream = new BufferedStream(_eventsFileStream, 10 * 1048576); //Each 1 MB has 1_048_576 bytes.

        ConfigureEventConsumer();

        WasEventCaptureStarted = true;
        IsAcceptingEvents = true;
    }

    private void ConfigureEventConsumer()
    {
        _eventConsumer ??= new BlockingCollection<RecordingEvent>();

        //Spin up a Task to consume the events generated by the recorder.
        _eventConsumerTask = Task.Factory.StartNew(() =>
        {
            try
            {
                while (true)
                {
                    var recordingEvent = _eventConsumer.Take();

                    if (recordingEvent.Type == RecordingEvents.Cursor)
                        SaveEvent((CursorEvent) recordingEvent);
                    else
                        SaveEvent((KeyEvent) recordingEvent);
                }
            }
            catch (InvalidOperationException)
            {
                //It means that Take() was called on a completed collection.
            }
            catch (Exception e)
            {
                Application.Current.Dispatcher.Invoke(() => OnError?.Invoke(e));
            }
        });
    }


    public virtual int CaptureWithCursor(FrameInfo frame)
    {
        return 0;
    }

    public virtual Task<int> CaptureWithCursorAsync(FrameInfo frame)
    {
        return null;
    }

    public virtual int ManualCapture(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursor(frame) : Capture(frame);
    }

    public virtual Task<int> ManualCaptureAsync(FrameInfo frame, bool showCursor = false)
    {
        return showCursor ? CaptureWithCursorAsync(frame) : CaptureAsync(frame);
    }


    public void RegisterCursorEvent(long ticksSinceStart, int x, int y, MouseButton buttons)
    {
        RegisterCursorEvent(ticksSinceStart, x, y, buttons, Cursor);
    }

    public void RegisterCursorEvent(long ticksSinceStart, int x, int y, MouseButton buttons, byte[] pixels)
    {
        if (!IsAcceptingFrames)
            return;

        _eventConsumer.Add(new CursorEvent
        {
            TimeStampInTicks = ticksSinceStart,
            Left = Left - x,
            Top = Top - y,
            PressedButtons = buttons,
            Width = (uint)CursorWidth,
            Height = (uint)CursorHeight,
            Pixels = pixels.ToArray()
        });
    }

    public void RegisterKeyEvent(long ticksSinceStart, Key key, ModifierKeys modifiers)
    {
        if (!IsAcceptingFrames)
            return;

        _eventConsumer.Add(new KeyEvent
        {
            TimeStampInTicks = ticksSinceStart,
            Key = key,
            Modifiers = modifiers
        });
    }

    public virtual void SaveEvent(CursorEvent cursorEvent)
    {
        _eventsBufferedStream.WriteByte(1); //Cursor event type.
        _eventsBufferedStream.WriteUInt64((ulong)cursorEvent.TimeStampInTicks); //TimeStamp since capture start.
        _eventsBufferedStream.WriteInt32(Left - cursorEvent.Left);
        _eventsBufferedStream.WriteInt32(Top - cursorEvent.Top);
        _eventsBufferedStream.WriteUInt64((ulong) cursorEvent.Pixels.Length);
        _eventsBufferedStream.WriteBytes(cursorEvent.Pixels);
    }

    public virtual void SaveEvent(KeyEvent keyEvent)
    {
        _eventsBufferedStream.WriteByte(2); //Key event type.
        _eventsBufferedStream.WriteUInt64((ulong)keyEvent.TimeStampInTicks); //TimeStamp since capture start.
        _eventsBufferedStream.WriteUInt32((uint)keyEvent.Key);
        _eventsBufferedStream.WriteByte((byte)keyEvent.Modifiers);
    }


    public override async Task Stop()
    {
        await base.Stop();

        if (!WasEventCaptureStarted)
            return;

        IsAcceptingEvents = false;

        //Stop the consumer thread.
        _eventConsumer.CompleteAdding();

        await _eventConsumerTask;

        //Finishing writing the events to the cache.
        await _eventsBufferedStream.FlushAsync();
        await _eventsFileStream.FlushAsync();

        await _eventsBufferedStream.DisposeAsync();
        await _eventsFileStream.DisposeAsync();

        WasEventCaptureStarted = false;
    }

    internal override async Task DisposeInternal()
    {
        await base.DisposeInternal();

        _eventConsumerTask?.Dispose();
        _eventConsumerTask = null;

        _eventConsumer?.Dispose();
        _eventConsumer = null;
    }
}